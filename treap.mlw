module Treap

    use int.Int

    type key = int
    type priority = int 
    type Tree = Leaf | Node tree key priority tree

    val hash (k : key) : priority

    let rec split (t : tree) (k : key) : (tree, bool, tree) =
        match t with 
          Leaf -> (Leaf, false, Leaf)
        | (Node l k1 p r) ->
            if k = k1 then (l, true, r)
            else if k < k1 then
                let (ll, x, lr) = split l k in (ll, x, Node lr k1 p r)
            else
                let (rl, x, rr) = split r k in (Node l k1 p rl, x, rr)
        end 
    
    let rec join (t1 : tree) (t2 : tree) : tree =
        match (t1, t2) with 
          (Leaf, _) -> t2 
        | (_, Leaf) -> t1
        | (Node l1 k1 p1 r1, Node l2 r2 p2 k2) ->
            if p1 > p2 then Node l1 k1 p1 (join r1 t2)
            else Node (join t1 l2) k2 p2 r2
        end

    (* old bst functions, need to add/modify contracts*)
    let empty () : tree = 
        ensures {valid_tree result}
        ensures {forall k. contains result k = false}
        Leaf
    
    let singleton (k : key) : tree =
        ensures {valid_tree result}
        ensures {contains result k}
        ensures {forall k1. k1 <> k -> contains result k1 = false}
        Node Leaf k (hash k) Leaf

    let delete (t : tree) (k : key) : tree =
        requires {valid_tree t}
        ensures {valid_tree result}
        ensures {contains result k = false}
        ensures {forall k1. contains result k1 -> contains t k1}
        let (l, _, r) = split t k in 
        join l r

    let joinM (t1 : tree) (k : key) (t2 : tree) : tree = 
        requires {valid_tree t1 /\ valid_tree t2}
        ensures {valid_tree result}
        ensures {forall k1. (contains t1 k1 \/ contains t2 k1 \/ k1 = k) <-> contains result k1}
        ensures {contains result k}
        join t1 (join (singleton k) t2)

    let insert (t : tree) (k : key) : tree =
        requires {valid_tree t}
        ensures {valid_tree result}
        ensures {forall k1. contains result k1 <-> (k1 = k \/ contains t k1)}
        ensures {contains result k}
        let (l, _, r) = split t k in 
        joinM l k r

    let rec intersection (t1 : tree) (t2 : tree) : tree =
        requires {valid_tree t1 /\ valid_tree t2}
        variant {t1}
        ensures {valid_tree result}
        ensures {forall k1. (contains t1 k1 /\ contains t2 k1) <-> contains result k1}
        match (t1, t2) with
          (Leaf, _) -> Leaf 
        | (_, Leaf) -> Leaf 
        | (Node l1 k1 r1, _) ->
            let (l2, b, r2) = split t2 k1 in
            let l = intersection l1 l2 in
            let r = intersection r1 r2 in 
            if b then joinM l k1 r else join l r 
        end

    (* t1 - t2 *)
    let rec difference (t1 : tree) (t2 : tree) : tree =
        requires {valid_tree t1 /\ valid_tree t2}
        variant {t1}
        ensures {valid_tree result}
        ensures {forall k. (contains t1 k /\ (not contains t2 k)) <-> contains result k}
        match (t1, t2) with 
          (Leaf, _) -> Leaf 
        | (_, Leaf) -> t1 
        | (Node l1 k1 r1, _) ->
            let (l2, b, r2) = split t2 k1 in 
            let l = difference l1 l2 in 
            let r = difference r1 r2 in 
            if b then join l r else joinM l k1 r
        end 

    let rec union (t1 : tree) (t2 : tree) : tree =
        requires {valid_tree t1 /\ valid_tree t2}
        variant {t1}
        ensures {valid_tree result}
        ensures {forall k1. (contains t1 k1 \/ contains t2 k1) <-> contains result k1}
        match (t1 ,t2) with 
          (Leaf, _) -> t2 
        | (_, Leaf) -> t1 
        | (Node l1 k1 r1, _) ->
            let (l2, _, r2) = split t2 k1 in 
            let l = union l1 l2 in 
            let r = union r1 r2 in 
            joinM l k1 r
        end
end